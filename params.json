{"name":"ActiveRecord fo CakePHP","tagline":"Active Record pattern implementation for CakePHP","body":"## Abstract\r\n\r\n[![Build Status](https://travis-ci.org/imsamurai/active-record-for-cakephp.png)](https://travis-ci.org/imsamurai/active-record-for-cakephp) [![Coverage Status](https://coveralls.io/repos/imsamurai/active-record-for-cakephp/badge.png?branch=master)](https://coveralls.io/r/imsamurai/active-record-for-cakephp?branch=master) [![Latest Stable Version](https://poser.pugx.org/imsamurai/active-record-for-cakephp/v/stable.png)](https://packagist.org/packages/imsamurai/active-record-for-cakephp) [![Total Downloads](https://poser.pugx.org/imsamurai/active-record-for-cakephp/downloads.png)](https://packagist.org/packages/imsamurai/active-record-for-cakephp) [![Latest Unstable Version](https://poser.pugx.org/imsamurai/active-record-for-cakephp/v/unstable.png)](https://packagist.org/packages/imsamurai/active-record-for-cakephp) [![License](https://poser.pugx.org/imsamurai/active-record-for-cakephp/license.png)](https://packagist.org/packages/imsamurai/active-record-for-cakephp)\r\n\r\n##Installation\r\n------------\r\nI wanted to build a state engine with CakePHP, and I realize that I needed a kind of Active Record pattern.\r\nSo I first built a behavior that allows me to retrieve objects in place of associative arrays.\r\n\r\nI have tested this only with cakePHP 2.3.x, 2.4.x\r\n\r\nComposer (for ex. version 1.0.0):\r\n\r\n```javascript\r\n{\r\n\t\"require\": {\r\n\t\t\"imsamurai/active-record-for-cakephp\": \"1.0.0\"\r\n\t}\r\n}\r\n```\r\n\t\r\nit installs in `Plugin` directory (in same level with composer.json) so you may want to add `Plugin/Task` into ignore file.\r\n\t\r\nor clone:\r\n\r\n\tcd my_cake_app/app\r\n\tgit clone git://github.com/imsamurai/active-record-for-cakephp.git Plugin/ActiveRecord\r\n\r\nor if you use git add as submodule:\r\n\r\n\tcd my_cake_app\r\n\tgit submodule add \"git://github.com/imsamurai/active-record-for-cakephp.git\" \"app/Plugin/ActiveRecord\"\r\n\r\nthen add plugin loading in Config/bootstrap.php\r\n\r\n\tCakePlugin::load('ActiveRecord', array('bootstrap' => true, 'routes' => false));\r\n\r\nTo use it:\r\n* Tell your model to use it: $actsAs = array('ActiveRecord' => array(<options>))\r\n* When you use a find('all') or find('first) function, add the option 'activeRecord' => true\r\n\r\nI chose this way, because I did not want to retrieve always objects when a find function was called.\r\nBut it is possible to use it in another way: add in the constructor of the behavior the option 'allFind' => true, and if you do not want an object after a find add 'activeRecord' => false (this possibility was not yet thouroughly tested: i'm afraid that cake generates sometimes a 'find' call that needs associative arrays).\r\n\r\n##How to use it\r\n-------------\r\nWhen you retrieve an object record, you can use it in this way: assume that you have the following models:\r\n* Post (title, message) belongsTo Writer, hasMany Comments, hasAndBelongsToMany Tags\r\n* Writer (name) hasMany Posts, belongsTo WriterGroup\r\n* WriterGroup (name) hasMany Writers\r\n* Comment (message) belongsTo Post\r\n* Tag (name) hasAndBelongsToMany Posts\r\n\r\nCall find('first') of find('all') to retrieve the posts and with one post you can do the following:\r\n* $message = $post->message : this retrieves the message of the post\r\n* $post->message = 'Hallo' : this updates the message of the post\r\n* $writer = $post->Writer : this retrieves the writer ActiveRecord object\r\n* $comments = $post->Comments : this retrieves the ActiveRecordAssociation object\r\n\r\nThe Behavior makes a difference between belongsTo/hasOne associations and hasMany/hasAndBelongsToMany associations:\r\n* with belongsTo and hasOne associations, the ActiveRecord object pointed by the association is retrieved, and you can use\r\nit directly: e.g. $post->Writer->WriterGroup->name\r\n* with hasMany and hasAndBelongsToMany associations, the ActiveRecordAssociation object is retrieved. The class of this object implements the IteratorAggregate, Countable and ArrayAccess interfaces so that you can use it as an array:\r\n\r\n  * foreach ($post->Comments as $comment) {}\r\n  * count($post->Comments);\r\n  * $comments = $post->Comments; $first_comment = $comments[0];\r\n\r\n\r\nBut also, the ActiveRecordAssociation class has 3 functions:\r\n  * $comments->add($new_comment);\r\n  * $comments->remove($first_comment);\r\n  * $comments->replace($first_comment, $new_comment);\r\n\r\nIn order for the developer to clearly see the difference beween the 2 kinds of associations, I advice to use a plural name for hasMany and hasAndBelongsToMany associations, and singular name for hasOne and belongsTo associations.\r\n\r\n##Extend ActiveRecord class\r\n-------------------------\r\nPer default, the object you retrieve is of the class ActiveRecord. But you can of course extend this class for one model.\r\nPer default, the behavior will look for a class in the subfolder Model/ActiveRecord with name 'AR<model name>', e.g.: ARPost or ARComment (the prefix 'AR' and the subfolder name can be changed in the bahavior constructor options).\r\nIn the file ARPost.php:\r\n\r\n    <?php\r\n    App::import('Model'.DS.'Behavior', 'ActiveRecord');\r\n\r\n    class ARTPost extends ActiveRecord {\r\n        public $var;\r\n        public function func() {...}\r\n    }\r\n    ?>\r\n\r\nIf you need to use the constructor:\r\n\r\n    public function __construct(array $record, array $options = array()) {\r\n       parent::__construct($record, $options);\r\n       ...\r\n    }\r\n\r\n\r\nThen you can use $post->var and $post->func() in your code.\r\nYou can also create new object:\r\n\r\n    $post = new ARPost(array(\r\n       'title' => 'My title',\r\n       'message' => 'OK',\r\n       'Writer' => $writer));\r\n\r\nHere it becomes to be quite nice: in place of telling that the writer_id of the post should be `$writer->id`, you can directly say `'Writer' => $writer`\r\nYou can also do:\r\n\r\n    $post->Comments = array($comment);\r\n\r\nThis will set automatically the `$comment->post_id` to the right one.\r\n\r\nUseful functions\r\n----------------\r\nI realize that when using hasMany (or hasOne association), when you do\r\n\r\n    $post->Comments->remove($comment);\r\n\r\nor\r\n\r\n    $post->Comments = null;\r\n\r\n\r\nYou want not only to remove the $comment from $post, but most of the time you want to delete $comment.\r\nI thought it would be quite handy if this is done automatically. For this, if you set in the association definition 'deleteWhenNotAssociated' to true, the behavior will automatically delete all records that are removed from the association.\r\n\r\nThe behavior offers also the possibility to delete, refresh and undo an ActiveRecord:\r\n\r\n    $post->delete(); // delete this post record\r\n    $post->refresh(); // query the values of post in the database.\r\n    $post->undo(); // undo all modification done in the $post record.\r\n\r\nThe modifications done in the active records are not sent to the database. This is done only when calling the save() method.\r\nBut $post->save() will only save the modification in the post record, not in its associated records. To save all modifications you made (explicitely and implicitely), use $post->saveAll() or ActiveRecord::saveAll() method\r\nMorevover saveAll() takes care that the records are saved in the right order. For example:\r\n\r\n    $comment = new ARComment(array('message' => 'New message'));\r\n    $post = new ARPost(array('title' => 'New title', 'message' => 'New Message', 'Writer' => $writer));\r\n    $post->Comment = array($comment);\r\n    ActiveRecord::saveAll();\r\n\r\nThen saveAll() takes care that $post is created first so that its id can be set to $comment->post_id.\r\n\r\nWhat is really nice with this Active Record pattern, is that you don't need anymore to bother about the keys and how you should construct the associated arrays to be sure that cakePHP will save correctly your data (especially with hasAndBelongsToMany associations!)\r\n\r\n##Extending even more\r\n-------------------\r\nI needed also a possiblility to have subclasses of ActiveRecord. For example I had an Action model, but I needed to define subclasses for each kind of action. A subclass action may use a (sub) model or not.\r\nFor this I told the behavior to check whether the Model has the function getActiveRecordProperties(), and if yes it calls it before it builds a new ActiveRecord.\r\nThis function tells the behavior what is the real ActiveAction name it must call, with which model and with which data. Here an example:\r\n\r\nMy model Action has a column type. This column will determine which kind of ActiveRecord class it must call.\r\nThen in the Action model, I have added this function:\r\n\r\n    public function getActiveRecordProperties(&$record) {\r\n      $type = $record[$this->alias]['type'];\r\n      $name = 'AR' . $type . 'Action';\r\n      $model = $this;\r\n      App::import('Model'.DS.'ActiveRecord', $name);\r\n      return array('name' => $name, 'Record' => $record, 'Model' => $model);\r\n    }\r\n\r\nMy ARAction looks like this:\r\n\r\n    abstract class ARAction extends AppActiveRecord {\r\n        abstract public function execute(ARUserState $user_state, $parameter);\r\n    }\r\n\r\nThe SendEmail subaction looks like that:\r\n\r\n    class ARSendEmailAction extends ARAction {\r\n       public function execute(ARUserState $user_state, $parameter) {\r\n           ....\r\n       }\r\n    }\r\n\r\nThen if I have a record in my Action table with type 'SendEmail', Action->find() returns an object of Class ARSendEmailAction. When calling execute(), it will call the right one that will send an email.\r\nHere the ARSendEmailAction uses the same model as ARAction, but if needed I could have set it to another one.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","google":"UA-54309823-1","note":"Don't delete this file! It's used internally to help with page regeneration."}